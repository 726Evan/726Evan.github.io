{"meta":{"title":"Evan","subtitle":"","description":"去樱顶看一次日出吧，看朝晖穿过薄雾洒在珞珈山上","author":"Evan","url":"https://726Evan.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-01-01T15:45:57.000Z","updated":"2022-01-01T15:46:49.500Z","comments":true,"path":"categories/index.html","permalink":"https://726evan.github.io/categories/index.html","excerpt":"","text":""},{"title":"新的开始","date":"2022-01-02T09:21:18.000Z","updated":"2022-01-03T09:32:13.266Z","comments":true,"path":"about/index.html","permalink":"https://726evan.github.io/about/index.html","excerpt":"","text":"hi 很高兴与你相遇，我是Evan，湖北第二师范学院二年级软件工程专业的一名学生。 这是我的第一个个人网站，它诞生于2022年1月2日的凌晨……两点多吧 ( 2022.1.2 2:12 ) 好像很早之前就有制作个人网站的想法了，但是受限于学业任务、各种各样的课外活动、科创竞赛和原神（它真的很好玩！不过我已经两个多月没怎么去提瓦特了，不知道应急食物有没有被别人吃掉 0_0 ） ，一直没有多余的时间，也不相信自己有足够的能力去制作一个个人网站，直到前不久（大二上学期）的专业实训，隔壁的小潘大佬说想做一个个人博客网站，这才唤醒了我尘封已久的小愿望。 但是专业实训开始的时候 (2021.12.27) ，距离期末考试只剩整整两周了，实训期间每天早八晚八，实训结束的第二天就开考了！根本没时间复习！两个星期做的完吗？两个星期做这个值得吗？很犹豫，保险起见，我去做了学生成绩管理系统，打算寒假回去再研究研究网站。 Program received signal SIGSEGV,Segmentation fault 来自指针的嘲笑 然而这个系统也不简单，链表和指针大哥指着我说，“你这个废物！” 再看小潘那边，好像做的还行？主界面的基本功能都有了，没想象的那么难（不过推倒重来六七次而已)。 所以，我就去做网站了。 怎么可能，软件工程专业的秃头怪从不屈服！只是跟浙大传说中的那位因为考前学习太过认真导致第二天睡过头错过大学物理考试从此大悟的计算机专业同学一样，我也大悟了。跟其他重点本科相比，我们同届的计算机专业学生在知识广度上基本落后别人半年甚至一年，深度可能更是永远也赶不上，毕业就失业真不是说着玩的。那咋办，考研吗？我之前也一直觉得非考研不可，但万一考不上呢，万一二战也不能上岸呢？大不了社招，大不了三战。这当然没问题，但我逐渐意识到，如果这样的话，相当于把二战三战、社招当作自己的退路，风险和成本都太高了，后果也难以接受，有没有更保险的方案？ 有，互联网大厂校招。 有人可能会说问，这和大四去实习有什么区别吗？有的，如果你的目标只是大四找个凑合的单位实习，凑合地过完这几年，谁敢保证你未来会比其他人有更高的追求？主方案一定比备用方案起点更高、目标更高，备用方案只是退路。但如果把考研当备用方案，把考研之前的大厂社招当作自己的第一目标，那么相较而言时间成本会少很多，未来下限会高很多，当然难度的陡增也毋庸置疑。 所以，掐指一算只剩一年的时间了。 数据结构老师：“实训时间很长，大家做完第一个系统之后还要再做一个小系统” …… 学生成绩管理系统完工后的第三天，我的小网站诞生了。 它暂时看起来比较简陋，许多功能做了很久但是没达到预期效果，而且不少的操作都是基于现有的框架，“自研率”不高。虽然如此，在它慢慢成长起来的这段时间里，我对命令行、计算机网络的相关知识可以说有所了解、有所实践，补足了一点点知识广度上的欠缺，也算作向着计算机领域的一次探索，待深入学习后再考虑更进一步的方向吧。 以上，这只是个开始，链表的头节点已经被赋予了内存空间，未来还有很长的路要走，但未来，很近很近……"},{"title":"标签","date":"2022-01-01T15:25:12.000Z","updated":"2022-01-01T15:43:56.659Z","comments":true,"path":"tags/index.html","permalink":"https://726evan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"友情链接","slug":"友情链接","date":"2022-01-02T07:15:32.000Z","updated":"2022-01-02T14:46:04.753Z","comments":true,"path":"2022/01/02/友情链接/","link":"","permalink":"https://726evan.github.io/2022/01/02/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/","excerpt":"","text":"这是 小潘同学 的网站，欢迎去围观~","categories":[],"tags":[{"name":"友情链接","slug":"友情链接","permalink":"https://726evan.github.io/tags/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/"}]},{"title":"C语言笔记——指针","slug":"C语言笔记——指针","date":"2022-01-01T15:35:11.000Z","updated":"2022-01-03T09:32:40.553Z","comments":true,"path":"2022/01/01/C语言笔记——指针/","link":"","permalink":"https://726evan.github.io/2022/01/01/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8C%87%E9%92%88/","excerpt":"指针与数组1.求数组长度若定义一个数组int a[]={1,2,3,4,5}","text":"指针与数组1.求数组长度若定义一个数组int a[]={1,2,3,4,5} 123456//数组总体占用字节数sizeof(a)=20；//数组中单个元素所占字节数sizeof(a[0])=4;//数组中的元素个数size=sizeof(a)/sizeof(a[0])=5 指针和数组1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int a[]=&#123;1,2,3,4,5&#125;; int i=0; int *p=a; printf(&quot;%d\\n&quot;,a+i); printf(&quot;%d\\n&quot;,p+i); printf(&quot;%d\\n&quot;,&amp;a[i]); printf(&quot;%d\\n&quot;,&amp;*(a+i)); printf(&quot;%d\\n&quot;,&amp;*(p+i)); printf(&quot;%d\\n&quot;,&amp;*&amp;a[i]); //以上全部输出地址 printf(&quot;----------\\n&quot;); //以下全部输出值 printf(&quot;%d\\n&quot;,a[i]); printf(&quot;%d\\n&quot;,*(a+i)); printf(&quot;%d\\n&quot;,*(p+i)); printf(&quot;%d\\n&quot;,*(&amp;a[i])); &#125; 数组作为函数参数12345678910111213141516int SumOfElements(int a[])&#123; int i,sum=0; int size=sizeof(a)/sizeof(a[0]); for(i=0;i&lt;size;i++) &#123; sum+=a[i]; &#125; return sum;&#125;int main()&#123; int a[]=&#123;1,2,3,4,5&#125;; int total=SumOfElements(a); printf(&quot;Sum of elements = %d\\n&quot;,total);&#125; 指针和字符数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;string.h&gt;void print1(char c[])&#123; int i=0; while(c[i] != &#x27;\\0&#x27;)&#123; printf(&quot;%c&quot;,c[i]); i++; &#125; printf(&quot;\\n&quot;);&#125;void print2(char* c)&#123; c[2]=&#x27;k&#x27;; int i=0; while(*(c+i) != &#x27;\\0&#x27;)&#123; printf(&quot;%c&quot;,c[i]); i++; &#125; printf(&quot;\\n&quot;);&#125;void print3(char* c)&#123; while(*c != &#x27;\\0&#x27;)&#123; printf(&quot;%c&quot;,*c); c++; &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; char c[10] = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\\0&#x27;&#125;; /*相当于char c[10] = &quot;hello&quot; 注意字符数组以\\0作为结束标志， 若：char c[5] = &quot;hello&quot;则报错, 应该把5改成6：char c[6] = &quot;hello&quot; 但用以下形式表示，不写\\0也合法， 如 char c[5] = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;*/ printf(&quot;%d\\n&quot;,sizeof(c)); //输出字符数组的总长度 printf(&quot;%d\\n&quot;,strlen(c)); //输出字符数组中第一个&#x27;\\0&#x27;之前元素的个数 print1(c); print2(c); /*1和2说明 (charc[]) 等价于 (char *c) 即c[i]与*(c+i)无条件等价 见书P237 while(c[i] != &#x27;\\0&#x27;) 等价于 while(*(c+i) != &#x27;\\0&#x27;) */ print3(c); /*3说明 void print3(char* c)中的c是指向数组基地址的指针，因此可以用c++对其使用自增操作 */&#125; 指针和二维数组123456789101112131415161718#include&lt;stdio.h&gt;int main()&#123; int b[2][3]=&#123;1,2,3,4,5,6&#125;; //b是一维数组的集合，其中的每一个（共2个）一维数组都有3个整型元素 int (*p)[3]=b; /*要注意它们的类型， b是一个指向一维数组（其中包含3个整型元素）的指针 若 int *p=b，则p是一个指向整型的指针，类型不同会编译错误*/ printf(&quot;%d %d &quot;,b,&amp;b[0]); //基地址 printf(&quot;%d %d %d\\n&quot;,*b,b[0],&amp;b[0][0]); //基地址 //b返回一个指向一维数组的指针，而*b返回一个指向整型的指针 printf(&quot;%d %d &quot;,b+1,&amp;b[1]); //基地址+3*4 printf(&quot;%d %d %d\\n&quot;,*(b+1),b[1],&amp;b[1][0]); //基地址+3*4 printf(&quot;%d %d %d\\n&quot;,*(b+1)+2,b[1]+2,&amp;b[1][2]); //基地址+3*4+2*4 printf(&quot;%d %d %d %d\\n&quot;,*(*b+1),*(b[0]+1),*&amp;b[0][1],b[0][1]); //（基地址+2*4）所在地址的值 //b[i][j] = *(b[i]+j) =*(*(b+i)+j) 三者等价 return 0;&#125; 指针和高维数组高维数组本质上是 数组的数组 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;void Fun1(int *x)//or x[]&#123;&#125;void Fun2(int (*y)[2])//or y[][2] &#123;&#125;void Fun3(int (*z)[2][2])//or z[][2][2] &#123;&#125; /*若用第二种形式需要注意数组的第一个维度可以省略但其余维度必须固定且对应实参*/ int main()&#123; int a[2]; int b[2][2]; int c[3][2][2]=&#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; Fun1(a);//一维数组作为参数传递给函数 Fun2(b);//二维数组作为参数传递给函数 Fun3(c);//三维数组作为参数传递给函数 int (*p)[2][2]=c; //c[i][j][k]=*(c[i][j]+k)=*(*(c[i]+j)+k)=*(*(*(c+i)+j)+k) printf(&quot;%d&quot;,*(c[1]+1)); //*(c[1]+1) = c[1][1] = &amp;c[1][1][0] return 0;&#125; 动态内存分配1 怎样建立内存的动态分配函数 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; void print(int a,int b[])//输出 &#123; printf(&quot;\\n&quot;); for(int i = 0 ; i &lt; a ; i++) &#123; printf(&quot;%d &quot;,b[i]); &#125; printf(&quot;\\n&quot;);&#125;void deliever(int a,int b[])//赋值 &#123; for(int i = 0 ; i &lt; a ; i++) &#123; b[i] = i+1 ; &#125;&#125; malloc 1234567int n1;printf(&quot;请输入数组的元素个数：\\t&quot;);scanf(&quot;%d&quot;,&amp;n1);int *A = (int*)malloc(n1*sizeof(int));print(n1,A);//未赋值前 ，存储垃圾值 deliever(n1,A);print(n1,A);//赋值后 calloc 1234567int n2;printf(&quot;请输入数组的元素个数：\\t&quot;);scanf(&quot;%d&quot;,&amp;n2);int *B = (int*)calloc(n2,sizeof(int));//calloc会将分配的内存初始化 print(n2,B);//未赋值前，已经初始化 deliever(n2,B);print(n2,B);//赋值后 realloc 12345678910int n3;printf(&quot;请输入数组的元素个数：\\t&quot;);scanf(&quot;%d&quot;,&amp;n3);int *C = (int*)malloc(n3*sizeof(int));print(n3,C);deliever(n3,C);print(n3,C);int *CC = (int*)realloc(C,2*n3*sizeof(int));//将内存大小扩展为原来的两倍 print(2*n3,CC);//扩展后的内存中的新内存部分仍然是垃圾值（若用calloc，则显示初始化后的值） free 12345678910111213int n4;printf(&quot;请输入数组的元素个数：\\t&quot;);scanf(&quot;%d&quot;,&amp;n4);int *D = (int*)malloc(n4*sizeof(int));print(n4,D);deliever(n4,D);print(n4,D);free(D);//free释放内存，若不释放可能导致内存泄露、程序崩溃 print(n4,D);D[n4-1] = 111; D[n4-2] = 222; D[n4-3] = 333;print(n4,D);//free之后依然可以修改 原内存的值的 所在地址的值","categories":[{"name":"C语言","slug":"C语言","permalink":"https://726evan.github.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"指针","slug":"C语言/指针","permalink":"https://726evan.github.io/categories/C%E8%AF%AD%E8%A8%80/%E6%8C%87%E9%92%88/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://726evan.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"指针","slug":"指针","permalink":"https://726evan.github.io/tags/%E6%8C%87%E9%92%88/"}]},{"title":"博客文章","slug":"博客文章","date":"2022-01-01T12:50:47.000Z","updated":"2022-01-02T14:44:31.538Z","comments":true,"path":"2022/01/01/博客文章/","link":"","permalink":"https://726evan.github.io/2022/01/01/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"这里什么都没有，看看别的吧~","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-01-01T11:57:36.767Z","updated":"2022-01-02T03:43:56.580Z","comments":true,"path":"2022/01/01/hello-world/","link":"","permalink":"https://726evan.github.io/2022/01/01/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"C语言","slug":"C语言","permalink":"https://726evan.github.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"指针","slug":"C语言/指针","permalink":"https://726evan.github.io/categories/C%E8%AF%AD%E8%A8%80/%E6%8C%87%E9%92%88/"}],"tags":[{"name":"友情链接","slug":"友情链接","permalink":"https://726evan.github.io/tags/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/"},{"name":"C语言","slug":"C语言","permalink":"https://726evan.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"指针","slug":"指针","permalink":"https://726evan.github.io/tags/%E6%8C%87%E9%92%88/"}]}